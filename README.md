# x86-64 компилятор

## Введение

Доброго дня всем читающим!

Этот проект представляет собой компилятор для [моего языка программирования](https://github.com/phrolow/Language). Компилятор считывает исходник, написанный на моём C-подобном языке (далее - "язык") и переводит его в дерево, по которому уже создаётся двоичный код из x86-64 команд. Результат работы компилятора - полноценный ELF-файл.

## О языке

Опишу вкратце возможности языка:

### Выражение

Выражение - комбинация констант, имен переменных, операторов **+**, **-**, **\***, **/**.
### Условия

Условие - комбинация выражения и логических операторов **||**, **&&**, **!**, **!=**, **==**, **<=**, **>=**, ""<**, **>**.
### Переменные (глобальные и локальные)

Глобальные переменные описываются вне функций, локальные - в функциях.

Присваивание переменной:

```
*имя_переменной* = *выражение*;
```

### Функции

Поддерживаются функции без аргументов и с одним аргументом. Функция может не возвращать значение.

```
func *название_функции*(*имя_переменной*) {
    *команды*

    return *выражение*;
}
```

### Вывод в консоль

```
print *выражение*;
```

### Считывание с консоли

```
scan *имя_переменной*;
```

### Оператор if-else

```
if(*условие*) {
    *команды*;
}
else {
    *команды*;
}
```

### Циклы while

```
while(*условие*) {
    *команды*;
}
```
## Дерево

Во многом базируется на [этом стандарте](https://github.com/futherus/Language/blob/master/tree_standard.md) (за исключением некоторых случаев, где правый и левый потомки переставлены местами)

![Мудре мистичне дерево](/tree.jpg)*Дерево программы, вычисляющего n-e число Фибоначчи 100000 раз*

## Трансляция

После перевода исходника в дерево компилятор начинает трансляцию дерева в ELF-файл. Первым делом создаются заголовок ELF-файла и заголовок сегмента (чуть позже я сделаю гайды по ним). В моём исполняемом файле всего один сегмент. Сегмент предоставляет доступ на чтение, запись и исполнение.

В начале сегмента лежат инструкции, выполняющиеся в начале исполнения программы для работы с памятью, отсюда же начинается блок данных длиной в **2 Кб**. Далее идёт "библиотека" программы - функции ввода/вывода, написанные мной на ассемблере и лежащие с адресами, кратными **1024**. Через **4 Кб** от начала сегмента лежит исполняемый код. Всего ELF-файл занимает **6 Кб**.

Компилятор совершает обход дерева при помощи алгоритма рекурсивного спуску. По итогу обхода создаются двоичный код, таблицы имён (глобальная и локальные) и таблица меток (пары "метка - адрес"). Далее исходный код перезаписывается уже с подстановкой адресов, вычисленных с помощью таблиц имён и меток. Такой приём называется двупроходной компиляцией.

## Тестирование

Для тестирования исходников я создал [юнит-тесты](https://github.com/phrolow/Compiler/Tests) и [тестирующие функции](https://github.com/phrolow/Compiler/src/Tests). В юнит-тесте первое число в строке - входное значение, второе - ожидаемое выходное.

Для замера времени работы я использовал свою [функцию measure()](https://github.com/phrolow/Compiler/src/Tests/testing.cpp).

Я тестировал программы, по **100000** раз вызывающие соответственно функции по нахождению факториала **n** и **n**-го числа Фибоначчи. Время работы для ELF-файлов:

| Исходник | Время работы, мс |
| -------- | ---------------- |
| fact.txt | 0.079            |
| fib.txt  | 0.055            |

Для сравнения я решил измерить время работы этих же программ, [исполняемых моей виртуальной машиной](https://github.com/phrolow/Language):

| Исходник | Время работы, мс |
| -------- | ---------------- |
| fact.txt | 0.069            |
| fib.txt  | 0.050            |

Без лишних предисловий: мужчина охуел.

## Вывод

Я вручную с нуля написал компилятор для C-подобного языка программирования. Я считаю этот опыт довольно ценным, ибо я понял, как работают реальные компиляторы. Т. к. я хочу связать свою профессию с написанием компиляторов, этот опыт мне пригодится.